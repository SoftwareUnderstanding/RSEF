{"somef_provenance": {"somef_version": "0.9.3", "somef_schema_version": "1.0.0", "date": "2023-06-21 12:57:33"}, "code_repository": [{"result": {"value": "https://github.com/OpenSYCL/OpenSYCL", "type": "Url"}, "confidence": 1, "technique": "GitHub_API"}], "owner": [{"result": {"value": "OpenSYCL", "type": "Organization"}, "confidence": 1, "technique": "GitHub_API"}], "date_created": [{"result": {"value": "2018-07-15T00:12:40Z", "type": "Date"}, "confidence": 1, "technique": "GitHub_API"}], "date_updated": [{"result": {"value": "2023-06-18T15:41:05Z", "type": "Date"}, "confidence": 1, "technique": "GitHub_API"}], "license": [{"result": {"value": "https://api.github.com/licenses/bsd-2-clause", "type": "License", "name": "BSD 2-Clause \"Simplified\" License", "url": "https://api.github.com/licenses/bsd-2-clause", "spdx_id": "BSD-2-Clause"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "\nCopyright (c) 2018 Aksel Alpay\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/LICENSE"}, {"result": {"value": "The MIT License (MIT)\n\nCopyright (c) 2017 Facebook Inc.\nCopyright (c) 2017 Georgia Institute of Technology\nCopyright 2019 Google LLC\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/include/hipSYCL/sycl/libkernel/detail/fp16/LICENSE"}], "description": [{"result": {"value": "Multi-backend implementation of SYCL for CPUs and GPUs", "type": "String"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Text_excerpt", "value": "Open SYCL is a modern SYCL implementation targeting CPUs and GPUs from all major vendors that supports many use cases and approaches for implementing SYCL: \n1. **A generic, single-pass compiler infrastructure that compiles kernels to a unified code representation** that is then lowered at runtime to target devices, providing a high degree of portability, low compilation times, flexibility and extensibility. Support includes:\n   1. NVIDIA CUDA GPUs through PTX;\n   2. AMD ROCm GPUs through amdgcn code;\n   3. Intel GPUs through SPIR-V;\n2. Additionally, **Open SYCL can aggregate existing clang toolchains and augment them with support for SYCL constructs**. This allows for a high degree of interoperability between SYCL and other models such as CUDA or HIP. Support includes:\n   1. Any LLVM-supported CPU (including e.g. x86, arm, power etc) through the regular clang host toolchain with dedicated compiler transformation to accelerate SYCL constructs;\n   2. NVIDIA CUDA GPUs through the clang CUDA toolchain;\n   3. AMD ROCm GPUs through the clang HIP toolchain;\n   4. Intel GPUs through oneAPI Level Zero and the clang SYCL toolchain (*highly* experimental)\n3. Or **Open SYCL can be used in library-only compilation flows**. In these compilation flows, Open SYCL acts as a C++ library for third-party compilers. This can have portability advantages or simplify deployment. This includes support:\n   1. Any CPU supported by any OpenMP compilers;\n   2. NVIDIA GPUs through CUDA and the NVIDIA nvc++ compiler, bringing NVIDIA vendor support and day 1 hardware support to the SYCL ecosystem \n\nOpen SYCL supports compiling source files into a single binary that can run on all these backends when building against appropriate clang distributions. Additionally, **Open SYCL is the only major SYCL implementation that supports a single-pass compiler design, where the code is only parsed once for both host and target devices**. More information about the supported [compilation flows can be found here](doc/compilation.md). \nThe runtime architecture of Open SYCL consists of the main library `hipSYCL-rt`, as well as independent, modular plugin libraries for the individual backends:\n![Runtime architecture](/doc/img/runtime.png) \nOpen SYCL's compilation and runtime design allows Open SYCL to \n* Either provide a **single, unified compiler infrastructure with a single code representation across all targets**, or\n* to **effectively aggregate multiple toolchains that are otherwise incompatible, making them accessible with a single SYCL interface.** \nThe philosophy behind Open SYCL is to leverage such existing toolchains as much as possible. This brings not only maintenance and stability advantages, but enables performance on par with those established toolchains by design, and also allows for maximum interoperability with existing compute platforms.\nFor example, the Open SYCL CUDA and ROCm backends rely on the clang CUDA/HIP frontends that have been augmented by Open SYCL to *additionally* also understand SYCL code. This means that the Open SYCL compiler can not only compile SYCL code, but also CUDA/HIP code *even if they are mixed in the same source file*, making all CUDA/HIP features - such as the latest device intrinsics - also available from SYCL code ([details](doc/hip-source-interop.md)). Additionally, vendor-optimized template libraries such as rocPRIM or CUB can also be used with Open SYCL. Consequently, Open SYCL allows for **highly optimized code paths in SYCL code for specific devices**. \nBecause a SYCL program compiled with Open SYCL looks just like any other CUDA or HIP program to vendor-provided software, vendor tools such as profilers or debuggers also work well with Open SYCL. \n", "original_header": "Open SYCL (formerly known as hipSYCL)"}, "confidence": 0.9500265340940546, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}, {"result": {"type": "Text_excerpt", "value": "While Open SYCL started its life as a hobby project, development is now led and funded by Heidelberg University. Open SYCL not only serves as a research platform, but is also a solution used in production on machines of all scales, including some of the most powerful supercomputers.\n \n", "original_header": "About the project"}, "confidence": 0.996199924921842, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}, {"result": {"type": "Text_excerpt", "value": "Open SYCL has been repeatedly shown to deliver very competitive performance compared to other SYCL implementations or proprietary solutions like CUDA. See for example: \n", "original_header": "Performance"}, "confidence": 0.8424722860757171, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}, {"result": {"type": "Text_excerpt", "value": "* Building Open SYCL against newer LLVM generally results in better performance for backends that are relying on LLVM.\n* Unlike other SYCL implementations that may rely on kernel compilation at runtime, Open SYCL relies heavily on ahead-of-time compilation. So make sure to use appropriate optimization flags when compiling.\n* For the CPU backend:\n   * Don't forget that, due to Open SYCL's ahead-of-time compilation nature, you may also want to enable latest vectorization instruction sets when compiling, e.g. using `-march=native`.\n   * Enable OpenMP thread pinning (e.g. `OMP_PROC_BIND=true`). Open SYCL uses asynchronous worker threads for some light-weight tasks such as garbage collection, and these additional threads can interfere with kernel execution if OpenMP threads are not bound to cores.\n   * Don't use `nd_range` parallel for unless you absolutely have to, as it is difficult to map efficiently to CPUs. \n      * If you don't need barriers or local memory, use `parallel_for` with `range` argument.\n      * If you need local memory or barriers, scoped parallelism or hierarchical parallelism models may perform better on CPU than `parallel_for` kernels using `nd_range` argument and should be preferred. Especially scoped parallelism also works well on GPUs.\n      * If you *have* to use `nd_range parallel_for` with barriers on CPU, the `omp.accelerated` compilation flow will most likely provide substantially better performance than the `omp.library-only` compilation target. See the [documentation on compilation flows](doc/compilation.md) for details.\n \n", "original_header": "General performance hints"}, "confidence": 0.9808022556127053, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}, {"result": {"type": "Text_excerpt", "value": "When targeting the CUDA or HIP backends, Open SYCL just massages the AST slightly to get `clang -x cuda` and `clang -x hip` to accept SYCL code. Open SYCL is not involved in the actual code generation. Therefore *any significant deviation in kernel performance compared to clang-compiled CUDA or clang-compiled HIP is unexpected.* \nAs a consequence, if you compare it to other llvm-based compilers please make sure to compile Open SYCL against the same llvm version. Otherwise you would effectively be simply comparing the performance of two different LLVM versions. This is in particular true when comparing it to clang CUDA or clang HIP. \n", "original_header": "Comparing against other LLVM-based compilers"}, "confidence": 0.8538267279538168, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}, {"result": {"type": "Text_excerpt", "value": "Open SYCL is not yet a fully conformant SYCL implementation, although many SYCL programs already work with Open SYCL.\n* SYCL 2020 [feature support matrix](https://github.com/hipSYCL/featuresupport)\n* A (likely incomplete) list of [limitations](doc/limitations.md) for older SYCL 1.2.1 features\n* A (also incomplete) timeline showing development [history](doc/history.md)\n \n", "original_header": "Current state"}, "confidence": 0.9843686864202648, "technique": "supervised_classification", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "name": [{"result": {"value": "OpenSYCL", "type": "String"}, "confidence": 1, "technique": "GitHub_API"}], "full_name": [{"result": {"value": "OpenSYCL/OpenSYCL", "type": "String"}, "confidence": 1, "technique": "GitHub_API"}], "issue_tracker": [{"result": {"value": "https://api.github.com/repos/OpenSYCL/OpenSYCL/issues", "type": "Url"}, "confidence": 1, "technique": "GitHub_API"}], "forks_url": [{"result": {"value": "https://api.github.com/repos/OpenSYCL/OpenSYCL/forks", "type": "Url"}, "confidence": 1, "technique": "GitHub_API"}], "stargazers_count": [{"result": {"value": 730, "type": "Number"}, "confidence": 1, "technique": "GitHub_API"}], "keywords": [{"result": {"value": "clang, cuda, gpgpu, gpu, gpu-computing, high-performance, high-performance-computing, hip, hipsycl, nvidia-cuda, opencl, opensycl, rocm, sycl", "type": "String"}, "confidence": 1, "technique": "GitHub_API"}], "forks_count": [{"result": {"value": 123, "type": "Number"}, "confidence": 1, "technique": "GitHub_API"}], "download_url": [{"result": {"value": "https://github.com/illuhad/hipSYCL/releases", "type": "Url"}, "confidence": 1, "technique": "GitHub_API"}], "programming_languages": [{"result": {"value": "C++", "name": "C++", "type": "Programming_language", "size": 3275308}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "CMake", "name": "CMake", "type": "Programming_language", "size": 77635}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "Shell", "name": "Shell", "type": "Programming_language", "size": 72655}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"value": "Python", "name": "Python", "type": "Programming_language", "size": 68140}, "confidence": 1, "technique": "GitHub_API"}], "releases": [{"result": {"type": "Release", "value": "https://api.github.com/repos/OpenSYCL/OpenSYCL/releases/89940761", "tag": "v0.9.4", "name": "hipSYCL 0.9.4", "author": {"name": "illuhad", "type": "User"}, "description": "\r\n\r\n**This is a maintenance release, intended as a last stop before major additions. It therefore does not include major functionality already available on the develop branch such as the generic single-pass compiler.**\r\n\r\n## What's Changed\r\n* Add minimal install script by @illuhad in https://github.com/illuhad/hipSYCL/pull/819\r\n* Fix handling of HCF object id when both CUDA and HIP are in explicit multipass by @illuhad in https://github.com/illuhad/hipSYCL/pull/831\r\n* Fix device::max_work_item_sizes by @nmnobre in https://github.com/illuhad/hipSYCL/pull/832\r\n* Add HIPSYCL_SYCLCC_EXTRA_COMPILE_OPTIONS by @al42and in https://github.com/illuhad/hipSYCL/pull/824\r\n* [CBS] Cope with a minor LLVM API change. by @fodinabor in https://github.com/illuhad/hipSYCL/pull/843\r\n* [CI] Enable LLVM 15. by @fodinabor in https://github.com/illuhad/hipSYCL/pull/844\r\n* replace activemask with ballot function by @DieGoldeneEnte in https://github.com/illuhad/hipSYCL/pull/838\r\n* Make embedded_pointer store pointer which than convert to unique_id rather than the other way round by @illuhad in https://github.com/illuhad/hipSYCL/pull/821\r\n* Update comment on nvc++ workaround in mem_fence() by @nmnobre in https://github.com/illuhad/hipSYCL/pull/849\r\n* Use -isystem instead of -I for hipSYCL headers to avoid warnings with high warning levels by @illuhad in https://github.com/illuhad/hipSYCL/pull/859\r\n* Add implicit conversion for item<1> to size_t by @illuhad in https://github.com/illuhad/hipSYCL/pull/847\r\n* Remove comparing `my_id` since it does not exist in class item by @nilsfriess in https://github.com/illuhad/hipSYCL/pull/868\r\n* Remove unnecessary/wrong consts by @nilsfriess in https://github.com/illuhad/hipSYCL/pull/876\r\n* Fix hipSYCL clang plugin path on MacOS by @illuhad in https://github.com/illuhad/hipSYCL/pull/883\r\n* Add vec deduction guides and fix swizzles when directly accessed using .elem() by @illuhad in https://github.com/illuhad/hipSYCL/pull/866\r\n* Ensure that `device{} == device{default_selector{}}` by @nilsfriess in https://github.com/illuhad/hipSYCL/pull/888\r\n* [CBS] Cleanup globals if unused loads still around by @fodinabor in https://github.com/illuhad/hipSYCL/pull/887\r\n* WIP: Fix MacOS build CI by @normallytangent in https://github.com/illuhad/hipSYCL/pull/882\r\n* Rename `global_mem_cache_type::write_only` to `read_write` by @nilsfriess in https://github.com/illuhad/hipSYCL/pull/875\r\n* Fix LLVM 16 compat. by @fodinabor in https://github.com/illuhad/hipSYCL/pull/893\r\n* Add clang include path from lib64. (Fix building on opensuse tumbleweed) by @marknefedov in https://github.com/illuhad/hipSYCL/pull/898\r\n\r\n## New Contributors\r\n* @marknefedov made their first contribution in https://github.com/illuhad/hipSYCL/pull/898\r\n\r\n**Full Changelog**: https://github.com/illuhad/hipSYCL/compare/v0.9.3...v0.9.4", "tarball_url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/tarball/v0.9.4", "zipball_url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/zipball/v0.9.4", "html_url": "https://github.com/OpenSYCL/OpenSYCL/releases/tag/v0.9.4", "url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/releases/89940761", "release_id": 89940761, "date_created": "2023-01-23T16:48:30Z", "date_published": "2023-01-23T16:58:19Z"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Release", "value": "https://api.github.com/repos/OpenSYCL/OpenSYCL/releases/75925433", "tag": "v0.9.3", "name": "hipSYCL 0.9.3", "author": {"name": "illuhad", "type": "User"}, "description": "## Highlights\r\n\r\n* Improved compatibility with new clang versions and ROCm clang\r\n* New extensions, e.g.\r\n  * coarse grained events. These are zero-construction-cost events at the expense of lower synchronization performance, and hence a good match if the returned event of an operation is not expected to be used\r\n  * queue priorities for in-order queues on certain backends\r\n* Added `hip.explicit-multipass` compilation flow\r\n* Multiple optimizations that can potentially reduce runtime overheads substantially\r\n  * Use event pools in CUDA/HIP backends\r\n  * Use asynchronous garbage collector thread to clean up old DAG nodes to remove garbage collection from the kernel submission path\r\n  * Use `std::weak_ptr` instead of `shared_ptr` to express dependencies in the DAG; making old DAG nodes and their associated events eligible earlier for reuse by the event pool.\r\n* In-order queues map 1:1 to dedicated CUDA or HIP streams for more explicit scheduling control\r\n* Unified kernel cache and data format for all explicit multipass compilation flow (hipSYCL container format, HCF)\r\n* Manage hipSYCL runtime lifetime by refcounting all SYCL objects created by the user instead of just having a global object; this can resolve errors when terminating the program on some backends.\r\n* Simplify deployment when no `std::filesystem` is available\r\n* New tool: `hipsycl-hcf-tool` to inspect and edit HCF files\r\n* New tool: `hipsycl-info` to print information about detected devices.\r\n\r\n## What's Changed (details)\r\n* Fix SPIR-V isnan() builtin by @illuhad in https://github.com/illuhad/hipSYCL/pull/710\r\n* Don't spill OpenMP pragmas and add .sycl as file ending by @illuhad in https://github.com/illuhad/hipSYCL/pull/711\r\n* Update installation scripts by @sbalint98 in https://github.com/illuhad/hipSYCL/pull/677\r\n* Fix typo in macro name causing harmless warnings by @al42and in https://github.com/illuhad/hipSYCL/pull/715\r\n* Check all dyn casts in analyzeModule. by @fodinabor in https://github.com/illuhad/hipSYCL/pull/717\r\n* Align name mangling in clang 13 host pass with upstream clang and restrict uses of createDeviceMangleContext() by @illuhad in https://github.com/illuhad/hipSYCL/pull/720\r\n* Add missing include directive for unordered_map by @normallytangent in https://github.com/illuhad/hipSYCL/pull/735\r\n* Make random number generators for embedded_pointer unique id thread_local by @illuhad in https://github.com/illuhad/hipSYCL/pull/738\r\n* Fix multi-threaded task processing by @illuhad in https://github.com/illuhad/hipSYCL/pull/739\r\n* dag_node: Only use backend wait() functionality if we are not yet complete by @illuhad in https://github.com/illuhad/hipSYCL/pull/742\r\n* Describe boost 1.78 build system bug in documentation by @illuhad in https://github.com/illuhad/hipSYCL/pull/744\r\n* Add released LLVM 14 to Linux CIs. by @fodinabor in https://github.com/illuhad/hipSYCL/pull/747\r\n* Add global kernel cache and HCF infrastructure by @illuhad in https://github.com/illuhad/hipSYCL/pull/736\r\n* Fix fiinding boost library path for boost with cmake intgeration  by @sbalint98 in https://github.com/illuhad/hipSYCL/pull/748\r\n* Use reference-counting of user SYCL objects to manage runtime lifetime by @illuhad in https://github.com/illuhad/hipSYCL/pull/749\r\n* Restrict queries of event state by @illuhad in https://github.com/illuhad/hipSYCL/pull/750\r\n* Fix signature of __hipsycl_atomic_store for double and float by @al42and in https://github.com/illuhad/hipSYCL/pull/751\r\n* [CUDA][HIP] Add event pool by @illuhad in https://github.com/illuhad/hipSYCL/pull/757\r\n* Add coarse grained events extension by @illuhad in https://github.com/illuhad/hipSYCL/pull/754\r\n* Make max cached nodes configurable by @illuhad in https://github.com/illuhad/hipSYCL/pull/759\r\n* [cbs] Fix compatibility issues with upstream Clang/LLVM by @aaronmondal in https://github.com/illuhad/hipSYCL/pull/763\r\n* [CBS] Fix runtime issues with opaque pointers by @fodinabor in https://github.com/illuhad/hipSYCL/pull/765\r\n* [Plugin] Resolve version macros in HIPSYCL_STRINGIFY by @aaronmondal in https://github.com/illuhad/hipSYCL/pull/773\r\n* Add missing sycl::nd_range::get_group_range function by @al42and in https://github.com/illuhad/hipSYCL/pull/775\r\n* Add HIPSYCL_RT_SANITIZE cmake option by @illuhad in https://github.com/illuhad/hipSYCL/pull/779\r\n* Update ROCm installation documentation by @illuhad in https://github.com/illuhad/hipSYCL/pull/780\r\n* Remove unnecessary linking against boost for the clang plugin by @illuhad in https://github.com/illuhad/hipSYCL/pull/781\r\n* Use weak_ptr in node requirements list by @illuhad in https://github.com/illuhad/hipSYCL/pull/771\r\n* [CI] fix compilation on MSVC 2017 by @fxzjshm in https://github.com/illuhad/hipSYCL/pull/784\r\n* dag_submitted_ops: Manage node lifetime by asynchronously waiting instead of event queries by @illuhad in https://github.com/illuhad/hipSYCL/pull/761\r\n* Optimize queue::wait() by waiting on nodes in reverse submission order by @illuhad in https://github.com/illuhad/hipSYCL/pull/787\r\n* Remove OpenMP dependency for sequential backend by @illuhad in https://github.com/illuhad/hipSYCL/pull/786\r\n* Optimize inorder queue::wait() by @illuhad in https://github.com/illuhad/hipSYCL/pull/788\r\n* Add support for HIP explicit multipass by @illuhad in https://github.com/illuhad/hipSYCL/pull/790\r\n* Add hipsycl-info tool by @illuhad in https://github.com/illuhad/hipSYCL/pull/791\r\n* Fix ThreadSanitizer complaint about worker_thread::_continue by @al42and in https://github.com/illuhad/hipSYCL/pull/794\r\n* Avoid printing unprintable from memset_operation::dump by @al42and in https://github.com/illuhad/hipSYCL/pull/795\r\n* Fix linking errors with libstdc++ < 9 by @al42and in https://github.com/illuhad/hipSYCL/pull/667\r\n* Use device managers in allocators instead of setting device directly by @illuhad in https://github.com/illuhad/hipSYCL/pull/796\r\n* Work around nvc++ bug by not having empty if target branches in mem_fence() by @illuhad in https://github.com/illuhad/hipSYCL/pull/798\r\n* Manually check version of clang if ROCm is used. by @fodinabor in https://github.com/illuhad/hipSYCL/pull/800\r\n* Implement sincos and sinh math builtins by @nmnobre in https://github.com/illuhad/hipSYCL/pull/802\r\n* Add dedicated backend queues for inorder queues and priority queue support by @illuhad in https://github.com/illuhad/hipSYCL/pull/770\r\n* Add HIPSYCL_EXT_QUEUE_PRIORITY flag by @al42and in https://github.com/illuhad/hipSYCL/pull/804\r\n* Fix CMake error with ROCm 4.5 Clang by @al42and in https://github.com/illuhad/hipSYCL/pull/806\r\n* Add option to compile tests with reduced local mem usage by @illuhad in https://github.com/illuhad/hipSYCL/pull/805\r\n* omp.library-only: Fix incorrect addition of master group offset to group id by @illuhad in https://github.com/illuhad/hipSYCL/pull/814\r\n* Bump version to 0.9.3 by @illuhad in https://github.com/illuhad/hipSYCL/pull/803\r\n\r\n\r\n## New Contributors\r\n* @normallytangent made their first contribution in https://github.com/illuhad/hipSYCL/pull/735\r\n* @aaronmondal made their first contribution in https://github.com/illuhad/hipSYCL/pull/763\r\n* @nmnobre made their first contribution in https://github.com/illuhad/hipSYCL/pull/802\r\n\r\nThank you to our first-time contributors!\r\n\r\n\r\n**Full Changelog**: https://github.com/illuhad/hipSYCL/compare/v0.9.2...v0.9.3", "tarball_url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/tarball/v0.9.3", "zipball_url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/zipball/v0.9.3", "html_url": "https://github.com/OpenSYCL/OpenSYCL/releases/tag/v0.9.3", "url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/releases/75925433", "release_id": 75925433, "date_created": "2022-08-31T16:32:41Z", "date_published": "2022-08-31T16:34:31Z"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Release", "value": "https://api.github.com/repos/OpenSYCL/OpenSYCL/releases/59532725", "tag": "v0.9.2", "name": "hipSYCL 0.9.2", "author": {"name": "illuhad", "type": "User"}, "description": "# Changes  compared to the previous release 0.9.1 (selection)\r\n\r\nThe following is an incomplete list of changes and improvements:\r\n\r\n## Highlights\r\n\r\n* Initial support for **operating as a pure CUDA library for NVIDIA's proprietary nvc++ compiler**, without any additional hipSYCL compiler magic. In this flow, LLVM is not required and new NVIDIA hardware can be targeted as soon as NVIDIA adds support in nvc++.\r\n* Initial support for **dedicated compiler support in the CPU backend**. These new compilation passes can greatly improve performance of nd_range parallel for kernels on CPU. **This allows executing SYCL code efficiently on any CPU supported by LLVM**.\r\n* **Scoped parallelism API v2** for a more performance portable programming model\r\n* Reimplement explicit multipass support for clang >= 13. This allows targeting multiple backends simultaneously, and was previously only supported on clang 11. Kernel names in the binary are now always demangleable as `__hipsycl_kernel<KernelNameT>` or `__hipsycl_kernel<KernelBodyT>`.\r\n\r\n## SYCL support\r\n\r\n* Support for new SYCL 2020 features such as `atomic_ref`, device selector API, device aspect API and others\r\n* Support for SYCL 2020 final group algorithm interface\r\n* Add support for the profiling API\r\n* ... more\r\n\r\n## Extensions\r\n\r\n* Add initial support for multi-device queue hipSYCL extension to automatically distribute work across multiple devices\r\n* Add initial support for `queue::get_wait_list()` hipSYCL extension to allow barrier-like semantics at the queue level\r\n* Add `accessor_variant` extension which allows accessors to automatically optimize the internal data layout of the accessor object depending on how they were constructed. This can save registers on device without any changes needed by the user.\r\n* Add `handler::update_device()` extension in analogy to already existing `update_host()`. This can be e.g. used to prefetch data.\r\n* Complete buffer-USM interoperability API\r\n* Add support for explicit buffer policy extension and asynchronous buffers\r\n\r\nSee the documentation on [extensions](https://github.com/illuhad/hipSYCL/blob/develop/doc/extensions.md) for more details.\r\n\r\n## Optimizations\r\n\r\n* Automatic work distribution across multiple streams\r\n* Fix massive performance bug caused by a bug in the kernel cache in the Level Zero backend\r\n* Optimize CUDA backend to perform aggressive CUDA module caching in an explicit multipass scenario. This can greatly improve performance of the `cuda.explicit-multipass` compilation flow when multiple translation units are involved.\r\n* Several performance fixes and improvements in the hipSYCL runtime. Especially when spawning many tasks, performance can now be significantly better.\r\n* ... more\r\n\r\n## Bug fixes and other improvements\r\n\r\nYes, a lot of them :-)\r\n", "tarball_url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/tarball/v0.9.2", "zipball_url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/zipball/v0.9.2", "html_url": "https://github.com/OpenSYCL/OpenSYCL/releases/tag/v0.9.2", "url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/releases/59532725", "release_id": 59532725, "date_created": "2022-02-14T17:07:50Z", "date_published": "2022-02-14T17:16:43Z"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Release", "value": "https://api.github.com/repos/OpenSYCL/OpenSYCL/releases/40646537", "tag": "v0.9.1", "name": "hipSYCL 0.9.1", "author": {"name": "illuhad", "type": "User"}, "description": "# hipSYCL 0.9.1\r\n\r\n*-- This release is dedicated to the memory of Oliver M. Some things just end too soon.*\r\n\r\n## New major features\r\n\r\n* **Add new \"explicit multipass\" compilation model**, allowing to simultaneously target all of hipSYCL's backends. **This means hipSYCL can now compile to a binary that runs can run on devices from multiple vendors**. Details on the compilation flow can be found here: https://github.com/illuhad/hipSYCL/blob/develop/doc/compilation.md\r\n* **Introduce plugin architecture for backends of the hipSYCL runtime**. This means hipSYCL now looks for backend plugins at runtime, allowing to extend an already existing hipSYCL installation with support for additional hardware without changing the already installed components.\r\n* **Initial, experimental support for Intel GPUs using Level Zero and SPIR-V**\r\n* **Introducing initial support for large portions of oneDPL** using our fork at https://github.com/hipSYCL/oneDPL\r\n* hipSYCL is now also tested on Windows in CI, although Windows support is still experimental.\r\n\r\n## New features and extensions\r\n* **Command group properties** that can influence how kernels or other operations are scheduled or executed:\r\n    * `hipSYCL_retarget` command group property. Execute an operation submitted to a queue on an arbitrary device instead of the one the queue is bound to.\r\n    * `hipSYCL_prefer_group_size<Dim>` command group property. Provides a recommendation to hipSYCL which group size to choose for basic parallel for kernels.\r\n    * `hipSYCL_prefer_execution_lane` command group property. Provides a hint to the runtime on which backend queue (e.g. CUDA stream) an operation should be executed. This can be used to optimize kernel concurrency or overlap of data transfers and compute in case the hipSYCL scheduler does not already automatically submit an optimal configuration.\r\n* **Comprehensive interoperability framework between buffers and USM pointers**. This includes extracting USM pointers from existing `buffer` objects, turning any `buffer` into a collection of USM pointers, as well as constructing `buffer` objects on top of existing USM pointers.\r\n* The `hipSYCL_page_size` buffer property can be used to enable data state tracking inside a buffer at a granularity below the buffer size. This can be used to **allow multiple kernels to concurrently write to the same buffer** as long as they access different hipSYCL data management pages. Unlike subbuffers, this also works with **multi-dimensional strided memory accesses**.\r\n* Synchronous `sycl::mem_advise()` as free function\r\n* `handler::prefetch_host()` and `queue::prefetch_host()` for a simpler mechanism of prefetching USM allocations to host memory.\r\n* **Explicit buffer policies to make programmer intent clearer** as well as **asynchronous buffer types that do not block in the destructor**, which can improve performance. For example, `auto v = sycl::make_async_view(ptr, range)` constructs a buffer that operates directly on the input pointer and does not block in the destructor.\r\n* `HIPSYCL_VISIBLITY_MASK` environment variable can be used to select which backends should be loaded.\r\n\r\nSee https://github.com/illuhad/hipSYCL/blob/develop/doc/extensions.md for a list of all hipSYCL extensions with more details.\r\n\r\n## Optimizations and improvements\r\n* Hand-tuned **optimizations for SYCL 2020 group algorithms**\r\n* **Automatic distribution of kernels across multiple CUDA/HIP streams**\r\n* Improved support for newer ROCm versions\r\n* SYCL 2020 accessor deduction guides and `host_accessor`\r\n* Improve handling of Multi-GPU setups\r\n* **Significant performance improvements for** `queue::wait()`\r\n* Early DAG optimizations to improve handling of complex and large dependency graphs\r\n* Optimizations to **elide unnecessary synchronization** between DAG nodes\r\n\r\n## Bug fixes and other improvements\r\n\r\nYes, a lot of them!", "tarball_url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/tarball/v0.9.1", "zipball_url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/zipball/v0.9.1", "html_url": "https://github.com/OpenSYCL/OpenSYCL/releases/tag/v0.9.1", "url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/releases/40646537", "release_id": 40646537, "date_created": "2021-03-29T16:34:02Z", "date_published": "2021-03-29T16:38:59Z"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Release", "value": "https://api.github.com/repos/OpenSYCL/OpenSYCL/releases/35100346", "tag": "v0.9.0", "name": "hipSYCL 0.9.0", "author": {"name": "illuhad", "type": "User"}, "description": "# hipSYCL 0.9.0\r\n\r\nhipSYCL 0.9 is packed with tons of new features compared to the older 0.8 series:\r\n\r\n# Support for key SYCL 2020 features\r\n\r\nhipSYCL 0.9.0 introduces support for several key SYCL 2020 features, including:\r\n* **Unified shared memory** provides a pointer-based memory model as an alternative to the traditional buffer-accessor model\r\n* SYCL 2020 **generalized backend model and backend interoperability** provides generic mechanisms for interoperability between the underlying backend objects and SYCL\r\n* **Queue shortcuts** for kernel invocation and USM memory management functions\r\n* **Inorder queues** to submit kernels in order when a task graph is not required\r\n* **Unnamed kernal lambdas** (requires building hipSYCL against clang >= 10)\r\n* **Subgroups**\r\n* **Group algorithms** for parallel primitives at work group and subgroup level (Note that the interface may change slightly with the release of SYCL 2020 final, optimization is ongoing)\r\n* **Reductions** provide a simple way to carry out arbitrary amounts of reduction operations across all work items of a kernel using either predefined or user-provided reduction operators (Note that the interface may change slightly with the release of SYCL 2020 final, optimization is ongoing). Currently only scalar reductions are supported. Multiple simultaneous reductions *are* supported. In addition to the requirements of the SYCL specification, we also support reductions for the hierarchical and scoped parallelism models.\r\n* ... and more! See here for more information on the SYCL 2020 coverage of current hipSYCL: https://github.com/hipSYCL/featuresupport\r\n\r\n# Unique hipSYCL extensions\r\n\r\nThere are two new extensions in hipSYCL 0.9.0:\r\n* **Enqueuing custom backend operations** for highly efficient backend interoperability: https://github.com/illuhad/hipSYCL/blob/develop/doc/enqueue-custom-operation.md\r\n* **Scoped parallellism** is a novel kernel execution model designed for performance portability between host and device backends: https://github.com/illuhad/hipSYCL/blob/develop/doc/scoped-parallelism.md\r\n\r\n# New runtime library\r\n\r\nhipSYCL 0.9.0 is the first release containing the entirely rewritten, brand new runtime library, which includes features such as:\r\n\r\n  * **Single library for all backends** (`libhipSYCL-rt`) instead of libraries for each backend (`libhipSYCL_cpu`, `libhipSYCL_cuda` etc)\r\n  * **Strict seperation between backend specific code and generic code**, clear, simple interface to add new backends, making it easy to add additional backends in the future\r\n  * **Multiple runtime backends can now be active at the same time and interact**\r\n  * SYCL interface is now header-only; bootstrap mode in `syclcc` is no longer required and has been removed. **When building hipSYCL, only the runtime needs to be compiled which can be done with any regular C++ compiler.** This should simplify the build process greatly.\r\n  * Architecture supports **arbitrary execution models in different backends** - queue/stream based, task graphs etc.\r\n  * **CUDA and CPU backends do not depend on HIP API anymore**. The CUDA backend now goes directly to CUDA without going through HIP, and the CPU backend goes directly to OpenMP without going through hipCPU. hipCPU and HIP submodules are no longer required and have been removed.\r\n  * **Strict separation between SYCL interface and runtime**, making it easy to expose new features (e.g. SYCL 2020) in the SYCL interface by leveraging the SYCL runtime interfaces underneath.\r\n  * For each operation, SYCL interface can pass additional information to runtime/scheduler using hints framework. **Device on which an operation is executed is just another hint for the runtime.**\r\n  * **Support for lazy DAG execution** (Note: Only partially activated by default)\r\n  * **Almost entirely callback-free execution model in CUDA/ROCm backends for potentially higher task throughput**\r\n  * **New memory management system and improved multi-GPU support**\r\n     - manages arbitrary allocations on multiple devices\r\n     - manages memory potentially below buffer granularity, using 3D page table to track invalid memory regions (not yet fully exposed)\r\n  * Backend queues (e.g. CUDA streams) are maintained by the backend in a pool, the scheduler then distributes operations across the queues. **No matter how many `sycl::queues` exist, compute/memory-overlap always works equally well.** This means a `sycl::queue` is now nothing more than an interface to the runtime.\r\n  * **Vastly improved error handling**. Proper implementation of async errors/error handlers. Task execution will be cancelled when an error is detected.\r\n  * **ROCm backend: Add support for 3D data transfers**\r\n\r\n# `syclcc` and compilation improvements\r\n* new `--hipsycl-targets` flag that allows to compile for multiple targets and backends, e.g. `syclcc --hipsycl-targets=\"omp;hip:gfx906,gfx900\"` compiles for the OpenMP backend as well as for Vega 10 and Vega 20. Note that simultaneous compilation for both NVIDIA and AMD GPUs is not supported due to clang limitations.\r\n* The compiler arguments and linker flags passed to backend compilers are now all exposed in cmake (and `syclcc.json`), giving the user more control to adapt the compilation flow to individual requirements. This can be helpful for uncommon setup scenarios where different flags may be required.\r\n\r\n# Performance improvements\r\n\r\n* New execution model for `nd_range` parallel for on CPU, bringing several orders of magnitudes of performance. Note that `nd_range` parallel for is inherently difficult to implement in library-only CPU backends, and basic `parallel for` or our scoped parallelism extension should be preferred if possible.\r\n\r\n# Fixes and other improvements\r\n\r\nYes, a lot of them :-)\r\n\r\n\r\n", "tarball_url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/tarball/v0.9.0", "zipball_url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/zipball/v0.9.0", "html_url": "https://github.com/OpenSYCL/OpenSYCL/releases/tag/v0.9.0", "url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/releases/35100346", "release_id": 35100346, "date_created": "2020-12-10T13:51:51Z", "date_published": "2020-12-10T13:55:00Z"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Release", "value": "https://api.github.com/repos/OpenSYCL/OpenSYCL/releases/20220027", "tag": "v0.8.0", "name": "hipSYCL 0.8.0", "author": {"name": "illuhad", "type": "User"}, "description": "**Note: hipSYCL 0.8.0 is deprecated**, *users are encouraged to use our [package repositories](https://github.com/illuhad/hipSYCL/blob/master/install/scripts/README.md#installing-from-repositories) instead*\r\n\r\nThis is the release of hipSYCL 0.8.0. We provide the following packages:\r\n\r\n* hipSYCL-base provides the basic LLVM compiler stack that is needed in any case\r\n* hipSYCL-rocm provides a compatible ROCm stack that additionally allows hipSYCL to target AMD GPUs\r\n* hipSYCL provides the actual hipSYCL libraries, tools and headers\r\n\r\nWhile we cannot provide matching CUDA packages for NVIDIA support due to legal reasons, scripts for installing a matching CUDA distribution as well as scripts to generate CUDA packages are provided. You will find further information in the readme here on github.\r\n\r\nAt the moment, Arch Linux, CentOS 7 and Ubuntu 18.04 packages are provided.\r\n", "tarball_url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/tarball/v0.8.0", "zipball_url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/zipball/v0.8.0", "html_url": "https://github.com/OpenSYCL/OpenSYCL/releases/tag/v0.8.0", "url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/releases/20220027", "release_id": 20220027, "date_created": "2019-09-24T16:08:22Z", "date_published": "2019-09-24T17:44:57Z"}, "confidence": 1, "technique": "GitHub_API"}, {"result": {"type": "Release", "value": "https://api.github.com/repos/OpenSYCL/OpenSYCL/releases/20124298", "tag": "v0.8.0-rc1", "name": "hipSYCL 0.8.0 Release Candidate 1", "author": {"name": "illuhad", "type": "User"}, "description": "This is a prerelease of hipSYCL 0.8.0. In particular, it serves to test new packages of the entire hipSYCL stack. We provide the following packages:\r\n* `hipSYCL-base` provides the basic LLVM compiler stack that is needed in any case\r\n* `hipSYCL-rocm` provides a compatible ROCm stack that additionally allows hipSYCL to target AMD GPUs\r\n* `hipSYCL` provides the actual hipSYCL libraries, tools and headers\r\n\r\nWhile we cannot provide matching CUDA packages due to legal reasons, CUDA installation scripts will be provided for the actual hipSYCL 0.8.0 release.\r\n\r\nAt the moment, Arch Linux and Ubuntu 18.04 packages are provided. ", "tarball_url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/tarball/v0.8.0-rc1", "zipball_url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/zipball/v0.8.0-rc1", "html_url": "https://github.com/OpenSYCL/OpenSYCL/releases/tag/v0.8.0-rc1", "url": "https://api.github.com/repos/OpenSYCL/OpenSYCL/releases/20124298", "release_id": 20124298, "date_created": "2019-09-19T14:54:58Z", "date_published": "2019-09-19T23:40:00Z"}, "confidence": 1, "technique": "GitHub_API"}], "readme_url": [{"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}], "contributing_guidelines": [{"result": {"value": "*Thank you for your interest in contributing to hipSYCL! Your PR will be highly appreciated* :-) \n\nWhen in doubt about how to implement something or how to integrate with the overall project strategy, please just open an issue for discussion.\n\n# Important branches in hipSYCL\n\nPlease take note of the branch structure of the project. The following are important branches:\n\n* `stable` - contains latest hipSYCL with additional testing. `stable` should always contain a version of hipSYCL that we are confident is stable.\n* `develop` - contains latest development version.\n* `sycl/VERSION` - contains hipSYCL code that targets a specific SYCL version.\n   - `sycl/1.2.1` - contains latest hipSYCL targeting SYCL 1.2.1. This branch is now mainly in maintenance mode. If you want to specifically improve hipSYCL SYCL 1.2.1 support, please use this branch.\n   - `sycl/2020` - contains latest hipSYCL work targeting SYCL 2020, and any work that is not specific to earlier SYCL versions.\n\nWe periodically perform the following merges:\n* `develop` -> `sycl/<latest-version>` -> `stable`\n\n\nPlease follow the following guidelines:\n* **File your PR against the `develop` branch, unless you are specifically targeting an earlier SYCL version.**\n* **If you are targeting an earlier SYCL version, target the appropriate `sycl/<version>` branch**\n   \n", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/CONTRIBUTING.md"}, {"result": {"value": "We encourage contributions and are looking forward to your pull request! Please have a look at [CONTRIBUTING.md](CONTRIBUTING.md). If you need any guidance, please just open an issue and we will get back to you shortly.\n\nIf you are a student at Heidelberg University and wish to work on Open SYCL, please get in touch with us. There are various options possible and we are happy to include you in the project :-)\n", "type": "Text_excerpt", "original_header": "Contributing to Open SYCL", "parent_header": ["Open SYCL (formerly known as hipSYCL)", "About the project"]}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "has_script_file": [{"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/rebuild-images.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/install-rocm.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/install-llvm.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/install-hipsycl.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/install-cuda.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/install-base-spack.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/hipsycl-minimal-install.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/spack-install/rocm.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/spack-install/llvm.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/spack-install/hipsycl.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/spack-install/cuda.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/spack-install/boost.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/packaging/make-ubuntu-pkg.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/packaging/make-ubuntu-cuda-pkg.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/packaging/make-centos-cuda-pkg.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/packaging/make-centos-8-pkg.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/packaging/make-centos-7-pkg.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/packaging/make-archlinux-pkg.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/packaging/make-archlinux-cuda-pkg.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/packaging/common/init.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/add-hipsycl-repo/ubuntu-20.04.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/add-hipsycl-repo/ubuntu-18.04.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/add-hipsycl-repo/centos-7.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/install/scripts/add-hipsycl-repo/archlinux-rolling.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/doc/cleanup_syclcchelp.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/update_repo.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/test-packages.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/test-installation.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/record_env_vars.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/publish_test_container.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/create_singularity_containers.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/create_repos.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/create_pkgs.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/repo-creation-scripts/create_ubuntu_repo.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/repo-creation-scripts/create_centos_repo.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/repo-creation-scripts/create_arch_repo.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}, {"result": {"value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/devops/repos/common/init.sh", "type": "Url"}, "confidence": 1, "technique": "file_exploration"}], "installation": [{"result": {"value": "\n# Building and installing Open SYCL\n\n## Manual installation (Linux)\n\n### Software dependencies\nIn order to successfully build and install Open SYCL, the following dependencies must be installed for all backends:\n\n* python 3 (for the `syclcc` and `syclcc-clang` compiler wrappers)\n* `cmake`\n* the Boost C++ libraries (in particular `boost.fiber`, `boost.context` and for the unit tests `boost.test`)\n  * it may be helpful to set the `BOOST_ROOT` `cmake` variable to the path to the root directory of Boost you wish to use if `cmake` does not find it automatically\n  * **Note for boost 1.78 users:** There seems to be a bug in the build system for boost 1.78, causing the compiled fiber and context libraries not to be copied to the installation directory. You will have to copy these libraries manually to the installation directory. In binary packages from some distribution repositories this issue is fixed. You might be only affected when building boost manually from source.\n\nIn addition, the various supported compilation flows have additional requirements (see [here](compilation.md) for more information on available compilation flows):\n\n| Compilation flow | Target hardware | Short description | Requirements |\n|------------------|-------------------|-------------------|-------------------|\n| `omp.library-only` | Any CPU | OpenMP CPU backend | Any OpenMP compiler |\n| `omp.accelerated` | Any CPU supported by LLVM | OpenMP CPU backend (compiler-accelerated)| LLVM >= 11 |\n| `cuda.integrated-multipass` | NVIDIA GPUs | CUDA backend (clang)| CUDA >= 10, LLVM >= 10 |\n| `cuda.explicit-multipass` | NVIDIA GPUs | CUDA backend (clang, can be targeted simultaneously with other backends) | CUDA >= 10, LLVM 11 or 13+ |\n| `cuda-nvcxx` | NVIDIA GPUs | CUDA backend (nvc++) | Latest NVIDIA HPC SDK |\n| `hip.integrated-multipass` | AMD GPUs (supported by ROCm) | HIP backend (clang) | ROCm >= 4.0, LLVM >= 10 |\n| `spirv` | Intel GPUs | SPIR-V/Level Zero backend | Level Zero driver and loader, clang with SYCL patches (e.g DPC++) |\n| `generic` | NVIDIA, AMD, Intel GPUs | Generic single-pass compiler | LLVM >= 14. When dispatching kernels to AMD hardware, ROCm >= 5.3 is recommended. When dispatching to NVIDIA, clang needs nvptx64 backend enabled. Open SYCL runtime backends for the respective target hardware need to be available. |\n\nPlease make sure to read the instructions below for the dependencies that apply to your use case.\n\n#### LLVM (skip if you only want flows without LLVM dependency)\n\nFollow [these](install-llvm.md) instructions.\n\n#### CUDA (skip if you don't need CUDA support)\n\nFollow [these](install-cuda.md) instructions\n\n#### ROCm (skip if you don't need ROCm support)\n\nFollow [these](install-rocm.md) instructions\n\n#### SPIR-V/Level Zero (skip if you don't need SPIR-V/Level Zero support)\n\nFollow [these](install-spirv.md) instructions.\n\n#### Building and installing \n\nOnce the software requirements mentioned above are met, clone the repository:\n```\n$ git clone https://github.com/OpenSYCL/OpenSYCL\n```\nThen, create a build directory and compile Open SYCL. As described below, some backends and compilation flows must be configured with specific cmake arguments which should be passed during the cmake step.\n\n```\n$ cd <build directory>\n$ cmake -DCMAKE_INSTALL_PREFIX=<installation prefix> <more optional options, e.g. to configure the LLVM dependency> <Open SYCL source directory>\n$ make install\n```\n\nThe default installation prefix is `/usr/local`. Change this to your liking.\n**Note: Open SYCL needs to be installed to function correctly; don't replace \"make install\" with just \"make\"!**\n\n##### CMake options to configure the Open SYCL build\n\n###### General\n*  `-DCMAKE_CXX_COMPILER` should be pointed to the C++ compiler to compile Open SYCL with. Note that this also sets the default C++ compiler for the CPU backend when using syclcc once Open SYCL is installed. This can however also be modified later using `HIPSYCL_CPU_CXX`.\n\n###### omp.library-only\n\n* `-DCMAKE_CXX_COMPILER` can be used to set the default OpenMP compiler.\n\n###### omp.accelerated\n\n* `-DWITH_ACCELERATED_CPU=OFF/ON` can be used to explicitly disable/enable CPU acceleration. Support for CPU acceleration is enabled by default when enabling the LLVM dependency, and LLVM is sufficiently new.\n\n###### cuda.*\n\n* See the CUDA [installation instructions](install-cuda.md) instructions (section on clang).\n\n###### cuda-nvcxx\n\n* See the CUDA [installation instructions](install-cuda.md) instructions (section on nvc++).\n\n###### hip.*\n\n* See the ROCm [installation instructions](install-rocm.md) instructions.\n\n###### spirv\n\n* No specific cmake flags are currently available.\n\n## Manual installation (Mac)\n\nOn Mac, only the CPU backends are supported. The required steps are analogous to Linux.\n\n## Manual installation (Windows)\n\nFor experimental building on Windows (CPU and CUDA backends) see the corresponding [wiki](https://github.com/OpenSYCL/OpenSYCL/wiki/Using-hipSYCL-on-Windows).\nThe `omp.accelerated` CPU compilation flow is unsupported on Windows.\n\n## Repositories (Linux)\n\n**Note: The software repositories mentioned below are outdated and in the process of being restructured. They do not contain modern Open SYCL versions.**\n\nAnother way to install Open SYCL is to use our repositories. We provide repositories for several distributions (currently Ubuntu 18.04, CentOS 7, Arch Linux). A description of the repositories is available [here](../install/scripts/README.md#installing-from-repositories)\n\nOur repositories cover the *entire software stack*, i.e. they include a compatible clang/LLVM distribution and ROCm stacks. The following packages are available:\n* `hipSYCL` - contains the actual Open SYCL libraries, tools and headers\n* `hipSYCL-base` - contains the LLVM/clang stack used by Open SYCL. Installation of this package is mandatory.\n* `hipSYCL-rocm` - contains a ROCm stack. This package is only required if you wish to target AMD ROCm GPUs.\n* `hipSYCL-nightly` - built from the current develop branch every day.\n* `hipSYCL-base-nightly` - contains the LLVM/clang stack for the nightly Open SYCL packages\n* `hipSYCL-rocm-nightly` - contains a ROCm stack compatible with the nightly Open SYCL packages\n\n**Note: For legal reasons, we do not redistribute the Open SYCL-cuda package** This package is only required if you wish to target CUDA GPUs. You will either have to create a CUDA package using `install/scripts/packaging/make-<distribution>-cuda-pkg.sh` or you can install CUDA directly using the `install/scripts/install-cuda.sh` script.\n\n\n## Installation scripts\nWe also provide scripts for packaging Open SYCL and its dependencies. For more information on packaging and how to create your own Open SYCL packages, please see the [documentation](../install/scripts/README.md).\n", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/doc/installing.md"}, {"result": {"value": "# Open SYCL installation instructions for SPIR-V/Level Zero\n\nPlease install the Level Zero loader and a Level Zero driver such as the Intel [compute runtime](https://github.com/intel/compute-runtime) for Intel GPUs.\n\nThe Level Zero backend can be enabled using `cmake -DWITH_LEVEL_ZERO_BACKEND=ON` when building Open SYCL.\n\n\n## For the legacy SPIR-V compilation flow (`--opensycl-targets=spirv`)\n**Please ignore the following if you actually want to use the more modern generic single-pass compiler (`--opensycl-targets=generic`), which is recommended.**\n\nPlease build Open SYCL against a clang/LLVM that has Intel's patches to generate SPIR-V, following the [LLVM installation instructions](install-llvm.md). Once all required patches are upstreamed this will work with regular clang distributions; until then Open SYCL needs to be built against DPC++/Intel's LLVM [fork](https://github.com/intel/llvm).\nUnfortunately, the binary distribution of DPC++ do not contain development headers, so the clang plugin required by the CUDA and ROCm backends cannot be compiled, but the open source fork should be able to also target CUDA and ROCm.\n\n", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/doc/install-spirv.md"}, {"result": {"value": "# Open SYCL installation instructions for ROCm\n\nPlease install ROCm 4.0 or later as described in the ROCm readme. Make sure to also install HIP (runtime libraries and headers).\n\n*Note: Newer ROCm versions may require building Open SYCL against newer clang versions as well. For example, ROCm 4.5 requires clang 13+.*\n\n*Note: Instead of building Open SYCL against a regular clang/LLVM, it is also possible to build Open SYCL against the clang/LLVM that ships with ROCm. This can be interesting if other available clang/LLVM installations are not new enough to work with the ROCm installation.* \n* **Such configurations typically work, but are generally less tested.**\n* Also note that the LLVM distributions shipping with ROCm are not official LLVM releases, and depending on when the upstream development was last merged, may have slightly diverging functionality. There are multiple known cases where this causes problems: \n  * The clang 13 from ROCm 4.5 lacks functionality that is present in official clang 13 releases and that Open SYCL's clang 13 code paths need. In that case you will need to set `-DHIPSYCL_NO_DEVICE_MANGLER=ON` when compiling Open SYCL. This will however break [explicit multipass](compilation.md) support.\n  * Similarly, the clang 14 from ROCm 5.0 lacks functionality that is present in official clang 14 releases. You can work around those issues by setting `-DWITH_ACCELERATED_CPU=OFF -DWITH_SSCP_COMPILER=OFF` at the expense of reduced kernel performance on CPUs and lack of [SSCP](compilation.md) support.\n\n*Note: Open SYCL is by default configured to utilize the ROCm compilation flags that apply for recent clang and ROCm versions. If you are using an older clang (<= 10) or ROCm < 4, you might have to adjust `-DROCM_CXX_FLAGS` (not recommended!).*\n\nCMake variables:\n* `-DROCM_PATH=/path/to/rocm` (default: /opt/rocm)\n* `-DWITH_ROCM_BACKEND=ON` if Open SYCL does not automatically enable the ROCm backend \n* `-DHIPSYCL_NO_DEVICE_MANGLER=OFF/ON` *if and only if* you build against ROCm's clang and hit the issue that it lacks functionality that regular clang 13 provides, and you cannot build Open SYCL otherwise. This *will* break [explicit multipass](compilation.md) support, i.e. you will not be able to compile for multiple device backends simultaneously.\n\n", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/doc/install-rocm.md"}, {"result": {"value": "# LLVM dependency installation instructions\n\nCertain backends/compilation flows require LLVM. This is because Open SYCL needs to build a clang plugin which is then loaded into clang to provide the required compiler support for SYCL.\n\nGenerally, we recommend the latest officially released clang/LLVM versions, but older versions might also work depending on the compilation flow (see the table from the main installation instructions).\n\nUsually, the clang/LLVM versions provided in Linux distribution repositories are sufficient, if they are recent enough. \n*In this case, Open SYCL might automatically detect and configure your LLVM installation without additional cmake arguments required.* **We therefore recommend to make your life easy: Check your distribution's LLVM version against the Open SYCL requirements and if they match, use it**.\n\nIf you are using Ubuntu or Debian, we can also recommend the package repositories at `http://apt.llvm.org` if you wish to obtain a newer LLVM.\n\nInstall\n* clang (including development headers)\n* LLVM (including development headers)\n* libomp (including development headers)\n* lld (only for the ROCm backend)\n\nFor example, the required steps to install clang 13 on an Ubuntu system are:\n```\nwget https://apt.llvm.org/llvm.sh #Convenience script that sets up the repositories\nchmod +x llvm.sh\n./llvm.sh 13 #Set up repositories for clang 13\napt install -y libclang-13-dev clang-tools-13 libomp-13-dev llvm-13-dev lld-13\n```\n\n#### Only if you wish to compile LLVM from source (not recommended)\n\nIt is generally not necessary to compile LLVM by yourself. However, if you wish to do this, during LLVM cmake make sure to:\n\n- Disable assertions as Open SYCL can potentially trigger some (false positive) debug assertions in some LLVM versions: `-DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=OFF -DLLVM_ENABLE_DUMP=OFF` \n- Generate `libLLVM.so`: `-DLLVM_BUILD_LLVM_DYLIB=ON` (only required if the SSCP compilation flow is enabled when building Open SYCL, which is true by default for supported versions of LLVM)\n- Enable the correct backends for your hardware: `nvptx` for NVIDIA GPUs and `amdgpu` for AMD GPUs.\n\n## Pointing Open SYCL to the right LLVM\n\nWhen invoking cmake, the Open SYCL build infrastructure will attempt to find LLVM automatically (see below for how to invoke cmake).\n\nIf Open SYCL does not automatically configure the build for the desired clang/LLVM installation, the following cmake variables can be used to point Open SYCL to the right one:\n* `-DLLVM_DIR=/path/to/llvm/cmake` must be pointed to your LLVM installation, specifically, the **subdirectory containing the LLVM cmake files**. Note that different LLVM installations may have the LLVM cmake files in different subdirectories that don't necessarily end with `cmake` (e.g. it might also be `/path/to/llvm/lib/cmake/llvm`). Alternatively, you can try `-DLLVM_ROOT` which might be more forgiving.\n\nVerify from the cmake that the selected `clang++` and include headers match the LLVM that you have requested. Example output:\n```\n...\n-- Building Open SYCL against LLVM configured from /usr/lib/llvm-13/cmake/\n-- Selecting clang: /usr/bin/clang++-13\n-- Using clang include directory: /usr/include/clang/13.0.1/include/..\n...\n```\n\nIf Open SYCL does not select the right clang++ or include directories, use the following variables to set them manually:\n\n\n* `-DCLANG_EXECUTABLE_PATH=/path/to/clang++` must be pointed to the `clang++` executable from this LLVM installation.\n* `-DCLANG_INCLUDE_PATH=/path/to/clang-includes` must be pointed to the clang internal header directory. Typically, this is something like `$LLVM_INSTALL_PREFIX/include/clang/<llvm-version>/include`. Newer ROCm versions will require the parent directory instead, i.e. `$LLVM_INSTALL_PREFIX/include/clang/<llvm-version>`. This is only important for the ROCm backend.\n", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/doc/install-llvm.md"}, {"result": {"value": "# Open SYCL installation instructions for CUDA\n\n## If using clang\n\nPlease install CUDA 10.0 or later.\n\nclang usually produces CUDA programs with very competitive performance compared to nvcc or nvc++. For more information on compiling CUDA with clang, please read [the LLVM documentation on CUDA support](http://llvm.org/docs/CompileCudaWithLLVM.html). **Note that the requirements on the CUDA installation described there.**\n\nIf you use a very recent CUDA version, you might get a warning when compiling with Open SYCL that clang does not support your CUDA version and treats like an older version. This warning can usually safely be ignored.\n\nCMake variables:\n* `-DCUDA_TOOLKIT_ROOT_DIR=/path/to/cuda` to point Open SYCL to the CUDA root installation directory (e.g. `/usr/local/cuda`), if cmake doesn't find the right CUDA installation.\n* `-DWITH_CUDA_BACKEND=ON` if Open SYCL does not automatically enable the CUDA backend \n\n## If using nvc++\n\nPlease install the latest release of the NVIDIA HPC SDK and make sure to point Open SYCL to nvc++ (see below).\nPlease install CUDA 10.0 or later. You can also rely on the CUDA bundled with the NVIDIA HPC SDK\n\nCMake variables:\n* `-DNVCXX_COMPILER=/path/to/nvc++`\n* You can use the CUDA bundled with nvc++. Make sure to point Open SYCL to the right CUDA installation using `-DCUDA_TOOLKIT_ROOT_DIR=/path/to/cuda`. \n* `-DWITH_CUDA_BACKEND=ON` if Open SYCL does not automatically enable the CUDA backend\n* `-DWITH_CUDA_NVCXX_ONLY=ON` enable if you want to use the CUDA backend exclusively with nvc++ and not clang. This will allow you to use nvc++ without having to install LLVM.", "type": "File_dump"}, "confidence": 1, "technique": "file_exploration", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/doc/install-cuda.md"}, {"result": {"value": "* [Building & Installing](doc/installing.md)\n\nIn order to compile software with Open SYCL, use `syclcc` which automatically adds all required compiler arguments to the CUDA/HIP compiler. `syclcc` can be used like a regular compiler, i.e. you can use `syclcc -o test test.cpp` to compile your SYCL application called `test.cpp` with Open SYCL.\n\n`syclcc` accepts both command line arguments and environment variables to configure its behavior (e.g., to select the target platform CUDA/ROCm/CPU to compile for). See `syclcc --help` for a comprehensive list of options.\n\nWhen compiling with Open SYCL, you will need to specify the targets you wish to compile for using the `--hipsycl-targets=\"backend1:target1,target2,...;backend2:...\"` command line argument, `HIPSYCL_TARGETS` environment variable or cmake argument. See the documentation on [using Open SYCL](doc/using-hipsycl.md) for details.\n\nInstructions for using Open SYCL in CMake projects can also be found in the documentation on [using Open SYCL](doc/using-hipsycl.md).\n", "type": "Text_excerpt", "original_header": "Installing and using Open SYCL", "parent_header": ["Open SYCL (formerly known as hipSYCL)"]}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "citation": [{"result": {"value": "Open SYCL is a research project. As such, if you use Open SYCL in your research, we kindly request that you cite one of the following publications, depending on your focus:\n\n* A general overview, SYCL 2020, performance and the relationship with oneAPI: *Aksel Alpay, B\u00e1lint Soproni, Holger W\u00fcnsche, and Vincent Heuveline. 2022. Exploring the possibility of a hipSYCL-based implementation of oneAPI. In International Workshop on OpenCL (IWOCL'22). Association for Computing Machinery, New York, NY, USA, Article 10, 1\u201312. https://doi.org/10.1145/3529538.3530005*\n* The generic single-pass compiler: *Aksel Alpay and Vincent Heuveline. 2023. One Pass to Bind Them: The First Single-Pass SYCL Compiler with Unified Code Representation Across Backends. In Proceedings of the 2023 International Workshop on OpenCL (IWOCL '23). Association for Computing Machinery, New York, NY, USA, Article 7, 1\u201312. https://doi.org/10.1145/3585341.3585351*\n* Our CPU compiler: *Joachim Meyer, Aksel Alpay, Sebastian Hack, Holger Fr\u00f6ning, and Vincent Heuveline. 2023. Implementation Techniques for SPMD Kernels on CPUs. In Proceedings of the 2023 International Workshop on OpenCL (IWOCL '23). Association for Computing Machinery, New York, NY, USA, Article 1, 1\u201312. https://doi.org/10.1145/3585341.3585342*\n* The original talk and the idea of implementing SYCL on non-OpenCL backends: *Aksel Alpay and Vincent Heuveline. 2020. SYCL beyond OpenCL: The architecture, current state and future direction of hipSYCL. In Proceedings of the International Workshop on OpenCL (IWOCL \u201920). Association for Computing Machinery, New York, NY, USA, Article 8, 1. DOI:https://doi.org/10.1145/3388333.3388658*\n\n(The latter is a talk and available [online](https://www.youtube.com/watch?v=kYrY80J4ZAs). Note that some of the content in this talk is outdated by now)\n", "type": "Text_excerpt", "original_header": "Citing Open SYCL", "parent_header": ["Open SYCL (formerly known as hipSYCL)", "About the project"]}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "acknowledgement": [{"result": {"value": "We gratefully acknowledge [contributions](https://github.com/illuhad/hipSYCL/graphs/contributors) from the community.\n", "type": "Text_excerpt", "original_header": "Acknowledgements", "parent_header": ["Open SYCL (formerly known as hipSYCL)", "About the project"]}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "support": [{"result": {"value": "Supported hardware:\n* Any CPU for which a C++17 OpenMP compiler exists\n* NVIDIA CUDA GPUs. Note that clang, which Open SYCL relies on, may not always support the very latest CUDA version which may sometimes impact support for *very* new hardware. See the [clang documentation](https://www.llvm.org/docs/CompileCudaWithLLVM.html) for more details.\n* AMD GPUs that are [supported by ROCm](https://github.com/RadeonOpenCompute/ROCm#hardware-support)\n\nOperating system support currently strongly focuses on Linux. On Mac, only the CPU backend is expected to work. Windows support with CPU and CUDA backends is experimental, see [Using Open SYCL on Windows](https://github.com/illuhad/hipSYCL/wiki/Using-hipSYCL-on-Windows).\n", "type": "Text_excerpt", "original_header": "Hardware and operating system support", "parent_header": ["Open SYCL (formerly known as hipSYCL)"]}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "documentation": [{"result": {"value": "* Open SYCL [design and architecture](doc/architecture.md)\n* Open SYCL runtime [specification](doc/runtime-spec.md)\n* Open SYCL [compilation model](doc/compilation.md)\n* How to use raw HIP/CUDA inside Open SYCL code to create [optimized code paths](doc/hip-source-interop.md)\n* A simple SYCL example code for testing purposes can be found [here](doc/examples.md).\n* [SYCL Extensions implemented in Open SYCL](doc/extensions.md)\n* [Macros used by Open SYCL](doc/macros.md)\n* [Environment variables supported by Open SYCL](doc/env_variables.md)\n\n\n\n", "type": "Text_excerpt", "original_header": "Documentation", "parent_header": ["Open SYCL (formerly known as hipSYCL)"]}, "confidence": 1, "technique": "header_analysis", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "full_title": [{"result": {"type": "String", "value": "Open SYCL (formerly known as hipSYCL)"}, "confidence": 1, "technique": "regular_expression", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "logo": [{"result": {"type": "Url", "value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop//doc/img/logo/logo-color.png"}, "confidence": 1, "technique": "regular_expression", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}], "image": [{"result": {"type": "Url", "value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop//doc/img/runtime.png"}, "confidence": 1, "technique": "regular_expression", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}, {"result": {"type": "Url", "value": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/doc/img/sycl-targets.png"}, "confidence": 1, "technique": "regular_expression", "source": "https://raw.githubusercontent.com/illuhad/hipSYCL/develop/README.md"}]}